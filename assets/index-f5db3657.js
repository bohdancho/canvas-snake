var w=Object.defineProperty;var P=(o,t,e)=>t in o?w(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var n=(o,t,e)=>(P(o,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();class x{constructor(t){n(this,"sizePx");n(this,"ctx");this.ctx=x.getContext(t);const{width:e,height:i}=t.getBoundingClientRect();t.width=e,t.height=i,this.sizePx=e}static getContext(t){const e=t.getContext("2d");if(!e)throw Error("No ctx");return e}}const g={field:{length:7},snake:{initLength:3,moveFrequencyMs:300},colors:{grid:"#6b7280",snake:"#3b82f6",food:"#ef4444"}};function f(o,t){return Math.floor(Math.random()*(t-o+1))+o}var l=(o=>(o.x_pos="x_pos",o.x_neg="x_neg",o.y_pos="y_pos",o.y_neg="y_neg",o))(l||{});function m(){const o=Object.values(l),t=f(0,o.length-1);return o[t]}function S(o,t){return o[0]!==t[0]}class L{constructor(t,e,i,s){n(this,"_entity",null);this.canvas=t,this.lengthPx=e,this.position=i,this.borderColor=s}update(t){var e;(e=this._entity)!=null&&e.onDestroy&&this._entity.onDestroy(),this._entity=t}render(){this._entity?this.paint(this._entity.color):this.clear()}get entity(){return this._entity}paint(t){this.canvas.ctx.fillStyle=t,this.canvas.ctx.fillRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx)}clear(){this.canvas.ctx.clearRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx),this.paintBorder()}paintBorder(){this.canvas.ctx.strokeStyle=this.borderColor,this.canvas.ctx.strokeRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx)}}class d{constructor(t,e){this.x=t,this.y=e}static areEqual(t,e){return t.x===e.x&&t.y===e.y}static random(t){const e=f(0,t-1),i=f(0,t-1);return new d(e,i)}}const a=class a{constructor(t){n(this,"squares");n(this,"squareLengthPx");this.canvas=t;const e=a.getSquareLengthPx(t,a.LENGTH);this.squareLengthPx=e,this.squares=a.getInitSquares(t,a.LENGTH,e)}initRender(){this.squares.forEach(t=>t.forEach(e=>{e.render()})),this.canvas.ctx.strokeStyle=a.GRID_COLOR,this.canvas.ctx.strokeRect(0,0,a.LENGTH*this.squareLengthPx,a.LENGTH*this.squareLengthPx)}updateSquare(t,e){this.getSquare(t).update(e)}renderSquare(t){this.getSquare(t).render()}getRandomFreePosition(){const t=d.random(a.LENGTH);return this.getSquare(t).entity?this.getRandomFreePosition():t}getSquare(t){return this.squares[t.y][t.x]}static getSquareLengthPx(t,e){return Math.floor(t.sizePx/e)}static getInitSquares(t,e,i){const s=[];for(let r=0;r<e;r++){s[r]=[];for(let c=0;c<e;c++)s[r][c]=new L(t,i,new d(c,r),a.GRID_COLOR)}return s}static getConnectedSquare(t,e){let{x:i,y:s}=e;switch(t){case l.x_pos:i++;break;case l.x_neg:i--;break;case l.y_pos:s++;break;case l.y_neg:s--;break}return new d(i,s)}static getLastSquare(t){const e=t.at(-1);if(!e)throw Error("Entity render error");return e}};n(a,"GRID_COLOR",g.colors.grid),n(a,"LENGTH",g.field.length);let h=a;class p{constructor(t,e,i){n(this,"color",g.colors.food);this.field=t,this.position=e,this.onEaten=i,this.field.updateSquare(e,this)}initRender(){this.field.renderSquare(this.position)}onDestroy(){this.onEaten()}}class b{constructor(t){n(this,"food");this.field=t}init(){this.generateFood()}generateFood(){this.food=new p(this.field,this.field.getRandomFreePosition(),this.onEaten.bind(this)),this.food.initRender()}onEaten(){this.generateFood()}}const q={ArrowLeft:l.x_neg,ArrowRight:l.x_pos,ArrowUp:l.y_neg,ArrowDown:l.y_pos};class I{constructor(t){this.actions=t}listen(){document.addEventListener("keydown",({key:t})=>{R(t)&&this.actions.changeDirection(q[t])})}}function R(o){return Object.keys(q).includes(o)}const u=class u{constructor(t,e){n(this,"color",g.colors.snake);n(this,"_direction");n(this,"requestedDirection");n(this,"body");n(this,"moveInterval");this.field=t,this.onCollapse=e;const i=m(),s=u.getInitialBody(h.LENGTH,i);s.forEach(r=>t.updateSquare(r,this)),this._direction=i,this.body=s}startMoving(){this.moveInterval=setInterval(()=>this.move(),u.MOVE_FREQUENCY)}stopMoving(){clearInterval(this.moveInterval)}move(){this.requestedDirection&&(this._direction=this.requestedDirection,this.requestedDirection=void 0);const t=this.getMove(),e=this.willEat(t);if(this.willCollapse(t)){this.stopMoving(),this.onCollapse();return}this.grow(t),e||this.trimTail()}get direction(){return this._direction}set direction(t){S(this.direction,t)&&(this.requestedDirection=t)}grow(t){this.body.push(t),this.field.updateSquare(t,this),this.field.renderSquare(t)}trimTail(){const t=this.body.shift();if(!t)throw Error("Snake move error");this.field.updateSquare(t,null),this.field.renderSquare(t)}willCollapse(t){return this.field.getSquare(t).entity===this}willEat(t){return this.field.getSquare(t).entity instanceof p}getMove(){const t=h.getLastSquare(this.body),e=h.getConnectedSquare(this._direction,t),i={x:e.x,y:e.y};return["x","y"].forEach(r=>{e[r]>=h.LENGTH&&(i[r]=0),e[r]<0&&(i[r]=h.LENGTH-1)}),new d(i.x,i.y)}static getInitialBody(t,e){const i=f(0,t-1),s=f(0,t-1),r=[new d(i,s)];for(let c=1;c<u.INIT_LENGTH;c++){const E=h.getLastSquare(r);r.push(h.getConnectedSquare(e,E))}return u.isBodyValid(t,r)?r:u.getInitialBody(t,e)}static isBodyValid(t,e){const{x:i,y:s}=h.getLastSquare(e);return i>=0&&s>=0&&i<t&&s<t}};n(u,"INIT_LENGTH",g.snake.initLength),n(u,"MOVE_FREQUENCY",g.snake.moveFrequencyMs);let y=u;class N{constructor(t){n(this,"field");n(this,"snake");n(this,"keyboard");n(this,"foodManager");const e=new x(t),i=new h(e),s=new y(i,this.onLoss);this.field=i,this.snake=s,this.keyboard=new I({changeDirection:r=>this.snake.direction=r}),this.foodManager=new b(i)}start(){this.field.initRender(),this.snake.startMoving(),this.foodManager.init(),this.keyboard.listen()}onLoss(){alert("you lost")}}const v=document.querySelector("#canvas");if(!v)throw Error("No canvas");const C=new N(v);C.start();
