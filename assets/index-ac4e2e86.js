var v=Object.defineProperty;var w=(n,t,e)=>t in n?v(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var o=(n,t,e)=>(w(n,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();class x{constructor(t){o(this,"sizePx");o(this,"ctx");this.ctx=x.getContext(t);const{width:e,height:i}=t.getBoundingClientRect();t.width=e,t.height=i,this.sizePx=e}static getContext(t){const e=t.getContext("2d");if(!e)throw Error("No ctx");return e}}function f(n,t){return Math.floor(Math.random()*(t-n+1))+n}var l=(n=>(n.x_pos="x_pos",n.x_neg="x_neg",n.y_pos="y_pos",n.y_neg="y_neg",n))(l||{});function P(){const n=Object.values(l),t=f(0,n.length-1);return n[t]}function m(n,t){return n[0]!==t[0]}const g={field:{length:7},snake:{initLength:3,moveFrequencyMs:300},colors:{grid:"#6b7280",snake:"#3b82f6",food:"#ef4444"}};class L{constructor(t,e,i,s){o(this,"_entity",null);this.canvas=t,this.lengthPx=e,this.position=i,this.borderColor=s}update(t){var e;(e=this._entity)!=null&&e.onDestroy&&this._entity.onDestroy(),this._entity=t}render(){this._entity?this.paint(this._entity.color):this.clear()}get entity(){return this._entity}paint(t){this.canvas.ctx.fillStyle=t,this.canvas.ctx.fillRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx)}clear(){this.canvas.ctx.clearRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx),this.paintBorder()}paintBorder(){this.canvas.ctx.strokeStyle=this.borderColor,this.canvas.ctx.strokeRect(this.lengthPx*this.position.x,this.lengthPx*this.position.y,this.lengthPx,this.lengthPx)}}class d{constructor(t,e){this.x=t,this.y=e}static areEqual(t,e){return t.x===e.x&&t.y===e.y}static random(t){const e=f(0,t-1),i=f(0,t-1);return new d(e,i)}}const a=class a{constructor(t){o(this,"squares");o(this,"squareLengthPx");this.canvas=t;const e=a.getSquareLengthPx(t,a.LENGTH);this.squareLengthPx=e,this.squares=a.getInitSquares(t,a.LENGTH,e)}initRender(){this.squares.forEach(t=>t.forEach(e=>{e.render()})),this.canvas.ctx.strokeStyle=a.GRID_COLOR,this.canvas.ctx.strokeRect(0,0,a.LENGTH*this.squareLengthPx,a.LENGTH*this.squareLengthPx)}updateSquare(t,e){this.getSquare(t).update(e)}renderSquare(t){this.getSquare(t).render()}getRandomFreePosition(){const t=d.random(a.LENGTH);return this.getSquare(t).entity?this.getRandomFreePosition():t}getSquare(t){return this.squares[t.y][t.x]}static getSquareLengthPx(t,e){return Math.floor(t.sizePx/e)}static getInitSquares(t,e,i){const s=[];for(let r=0;r<e;r++){s[r]=[];for(let c=0;c<e;c++)s[r][c]=new L(t,i,new d(c,r),a.GRID_COLOR)}return s}static getConnectedSquare(t,e){let{x:i,y:s}=e;switch(t){case l.x_pos:i++;break;case l.x_neg:i--;break;case l.y_pos:s++;break;case l.y_neg:s--;break}return new d(i,s)}static getLastSquare(t){const e=t.at(-1);if(!e)throw Error("Entity render error");return e}};o(a,"GRID_COLOR",g.colors.grid),o(a,"LENGTH",g.field.length);let h=a;class p{constructor(t,e,i){o(this,"color",g.colors.food);this.field=t,this.position=e,this.onEaten=i,this.field.updateSquare(e,this)}initRender(){this.field.renderSquare(this.position)}onDestroy(){this.onEaten()}}const q={ArrowLeft:l.x_neg,ArrowRight:l.x_pos,ArrowUp:l.y_neg,ArrowDown:l.y_pos};class b{constructor(t){this.actions=t}listen(){document.addEventListener("keydown",({key:t})=>{I(t)&&this.actions.changeDirection(q[t])})}}function I(n){return Object.keys(q).includes(n)}const u=class u{constructor(t,e){o(this,"color",g.colors.snake);o(this,"_direction");o(this,"requestedDirection");o(this,"body");o(this,"moveInterval");this.field=t,this.onCollapse=e;const i=P(),s=u.getInitialBody(h.LENGTH,i);s.forEach(r=>t.updateSquare(r,this)),this._direction=i,this.body=s}startSnake(){this.moveInterval=setInterval(()=>this.move(),u.MOVE_FREQUENCY)}stopSnake(){clearInterval(this.moveInterval)}move(){this.requestedDirection&&(this._direction=this.requestedDirection,this.requestedDirection=void 0);const t=this.getMove(),e=this.willEat(t);if(this.willCollapse(t)){this.stopSnake(),this.onCollapse();return}this.grow(t),e||this.trimTail()}get direction(){return this._direction}set direction(t){this.requestedDirection=t}grow(t){this.body.push(t),this.field.updateSquare(t,this),this.field.renderSquare(t)}trimTail(){const t=this.body.shift();if(!t)throw Error("Snake move error");this.field.updateSquare(t,null),this.field.renderSquare(t)}willCollapse(t){return this.field.getSquare(t).entity===this}willEat(t){return this.field.getSquare(t).entity instanceof p}getMove(){const t=h.getLastSquare(this.body),e=h.getConnectedSquare(this._direction,t),i={x:e.x,y:e.y};return["x","y"].forEach(r=>{e[r]>=h.LENGTH&&(i[r]=0),e[r]<0&&(i[r]=h.LENGTH-1)}),new d(i.x,i.y)}static getInitialBody(t,e){const i=f(0,t-1),s=f(0,t-1),r=[new d(i,s)];for(let c=1;c<u.INIT_LENGTH;c++){const S=h.getLastSquare(r);r.push(h.getConnectedSquare(e,S))}return u.isBodyValid(t,r)?r:u.getInitialBody(t,e)}static isBodyValid(t,e){const{x:i,y:s}=h.getLastSquare(e);return i>=0&&s>=0&&i<t&&s<t}};o(u,"INIT_LENGTH",g.snake.initLength),o(u,"MOVE_FREQUENCY",g.snake.moveFrequencyMs);let y=u;class R{constructor(t){o(this,"field");o(this,"snake");o(this,"keyboard");o(this,"food");o(this,"actions",{changeDirection:t=>{m(this.snake.direction,t)&&(this.snake.direction=t)},foodEaten:()=>{this.food=this.generateFood(),this.food.initRender()}});const e=new x(t),i=new h(e),s=new y(i,this.onLoss);this.field=i,this.snake=s,this.keyboard=new b(this.actions),this.food=this.generateFood()}start(){this.field.initRender(),this.snake.startSnake(),this.keyboard.listen()}generateFood(){return new p(this.field,this.field.getRandomFreePosition(),this.actions.foodEaten)}onLoss(){alert("you lost")}}const E=document.querySelector("#canvas");if(!E)throw Error("No canvas");const N=new R(E);N.start();
